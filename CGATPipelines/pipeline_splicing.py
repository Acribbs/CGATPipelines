##############################################################################
#
#   MRC FGU CGAT
#
#   $Id$
#
#   Copyright (C) 2009 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################
"""===========================
Pipeline rMATS
===========================

:Author: Jakub Scaber
:Release: $Id$
:Date: |today|
:Tags: Python

Overview
========

rMATS a computational tool to detect differential alternative splicing events
from RNA-Seq data. The statistical model of MATS calculates the P-value and
false discovery rate that the difference in the isoform ratio of a gene
between two conditions exceeds a given user-defined threshold. From the
RNA-Seq data, MATS can automatically detect and analyze alternative splicing
events corresponding to all major types of alternative splicing patterns.
MATS handles replicate RNA-Seq data from both paired and unpaired study design.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.ini` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_rMATS.py config

Input files
-----------

".bam" files generated using Tophat or Tophat2. Other mappers
may also work.

Design_files ("*.design.tsv") are used to specify sample variates. The
minimal design file is shown below, where include specifies if the
sample should be included in the analysis, group specifies the sample
group and pair specifies whether the sample is paired. Note, multiple
design files may be included, for example so that multiple models can
be fitted to different subsets of the data

(tab-seperated values)

sample    include    group    pair
WT-1-1    1    WT    0
WT-1-2    1    WT    0
Mutant-1-1    1    Mutant    0
Mutant-1-2    1    Mutant    0

The pipeline can only handle comparisons between two conditions with
replicates. If further comparisons are needed, further design files
should be used.

Requirements
------------

The pipeline requires the results from
:doc:`pipeline_annotations`. Set the configuration variable
:py:data:`annotations_database` and :py:data:`annotations_dir`.

For paired end data, the pipeline also requires picard data on
insert size length and standard deviation which are obtained from
the csvdb of :doc:`pipeline_mapping`

Please remember to load samtools version 0.1.19 in your (virtual)
environment when running this pipeline. Newer versions of samtools
will fail.

Requirements:

* samtools = 1.1.19


Pipeline output
===============

For each experiment, the output from rMATS is placed in a folder
named "condition1_vs_condition2".

rMATS output is further described here:
http://rnaseq-mats.sourceforge.net/user_guide.htm



Glossary
========

.. glossary::


Code
====

"""
from ruffus import *
import sys
import os
import glob
import sqlite3
import pandas
import CGAT.BamTools as BamTools
import CGAT.Experiment as E
import CGAT.Expression as Expression
import CGATPipelines.Pipeline as P
import CGATPipelines.PipelineTracks as PipelineTracks

# load options from the config file
PARAMS = P.getParameters(
    ["%s/pipeline.ini" % os.path.splitext(__file__)[0],
     "../pipeline.ini",
     "pipeline.ini"])

# add configuration values from associated pipelines
#
# 1. pipeline_annotations: any parameters will be added with the
#    prefix "annotations_". The interface will be updated with
#    "annotations_dir" to point to the absolute path names.
PARAMS.update(P.peekParameters(
    PARAMS["annotations_dir"],
    "pipeline_annotations.py",
    on_error_raise=__name__ == "__main__",
    prefix="annotations_",
    update_interface=True))


# -----------------------------------------------
# Utility functions
def connect():
    '''utility function to connect to database.

    Use this method to connect to the pipeline database.
    Additional databases can be attached here as well.

    Returns an sqlite3 database handle.
    '''

    dbh = sqlite3.connect(PARAMS["database"])
    statement = '''ATTACH DATABASE '%s' as annotations''' % (
        PARAMS["annotations_database"])
    cc = dbh.cursor()
    cc.execute(statement)
    cc.close()

    return dbh


class MySample(PipelineTracks.Sample):
    attributes = tuple(PARAMS["attributes"].split(","))

TRACKS = PipelineTracks.Tracks(MySample).loadFromDirectory(
    glob.glob("*.bam"), "(\S+).bam")

Sample = PipelineTracks.AutoSample
DESIGNS = PipelineTracks.Tracks(Sample).loadFromDirectory(
    glob.glob("*.design.tsv"), "(\S+).design.tsv")

# ---------------------------------------------------
# Specific pipeline tasks


@mkdir("results.dir")
@subdivide(["%s.design.tsv" % x.asFile().lower() for x in DESIGNS],
           regex("(\S+).design.tsv"),
           r"results.dir/\1.dir")
def runMATS(infile, outfile):
    '''run rMATS.'''

    design = infile
    Design = Expression.ExperimentalDesign(design)
    if len(Design.groups) != 2:
        raise ValueError("Please specify exactly two groups per experiment.")

    group1 = ",".join(
        ["%s.bam" % x for x in Design.getSamplesInGroup(Design.groups[0])])
    group2 = ",".join(
        ["%s.bam" % x for x in Design.getSamplesInGroup(Design.groups[1])])

    statement = '''python %(MATS_executable)s/RNASeq-MATS.py
    -b1 %(group1)s
    -b2 %(group2)s
    -gtf <(gunzip < %(gtf)s)
    -o %(outfile)s
    -t %(MATS_readtype)s
    -len %(MATS_readlength)s
    -c %(MATS_cutoff)s
    '''

    if Design.has_pairs:
        statement += "-analysis P "

    # When paired data is used, insert sizes are pulled from picard stats
    # obtained during mapping
    if BamTools.isPaired(Design.samples[0]+".bam"):
        dbh = sqlite3.connect(PARAMS["MATS_mappingdb"])
        df = pandas.read_sql("""SELECT track, MEAN_INSERT_SIZE,
        STANDARD_DEVIATION FROM picard_stats_insert_size_metrics

        WHERE track LIKE '%%%s'""" % PARAMS["MATS_mapper"],
                             dbh, index_col="track")
        dbh.close()
        df.sort_index(inplace=True)

        r = ["", ""]
        sd = ["", ""]
        for x in range(0, 2):
            r_list = []
            sd_list = []
            for sample in Design.getSamplesInGroup(Design.groups[x]):
                # index matching avoids pulling merged sub-samples from
                # the mapping database
                r_list += df.ix[df.index.str.match("%s\..*" % sample),
                                "MEAN_INSERT_SIZE"].tolist()
                sd_list += df.ix[df.index.str.match("%s\..*" % sample),
                                 "STANDARD_DEVIATION"].tolist()
            r[x] = ",".join(map(str, r_list))
            sd[x] = ",".join(map(str, sd_list))

        statement += "-r1 %s -r2 %s -sd1 %s -sd2 %s" % (r[0], r[1],
                                                        sd[0], sd[1])

    P.run()


# ---------------------------------------------------
# Generic pipeline tasks
@follows(runMATS)
def full():
    pass


@follows(mkdir("report"))
def build_report():
    '''build report from scratch.

    Any existing report will be overwritten.
    '''

    E.info("starting report build process from scratch")
    P.run_report(clean=True)


@follows(mkdir("report"))
def update_report():
    '''update report.

    This will update a report with any changes inside the report
    document or code. Note that updates to the data will not cause
    relevant sections to be updated. Use the cgatreport-clean utility
    first.
    '''

    E.info("updating report")
    P.run_report(clean=False)


@follows(update_report)
def publish_report():
    '''publish report in the CGAT downloads directory.'''

    E.info("publishing report")
    P.publish_report()

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
